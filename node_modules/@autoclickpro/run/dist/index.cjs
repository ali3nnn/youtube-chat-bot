'use strict';

var minimist = require('minimist');
var _ = require('lodash-es');

function createProxy(object) {
  return new Proxy(object, {
    apply(target, thisArg, argArray) {
      return Reflect.apply(target, thisArg, argArray);
    },
    get(target, prop, receiver) {
      if (prop in target) {
        return Reflect.get(target, prop, receiver);
      }
      if ('default' in target) {
        return Reflect.get(target, 'default', receiver);
      }
      throw new Error(`no such command: ${prop}`);
    }
  });
}
async function run(cmdMap, ministOpts) {
  const proxyCmdMap = createProxy(cmdMap);
  const argv = minimist(process.argv.slice(2), ministOpts);
  if (argv.help) {
    console.log(proxyCmdMap);
    return;
  }
  const subCmds = argv._;
  if (!subCmds) {
    throw new Error(`caution:subcommand is needed. and handler current is ${subCmds}`);
  }
  if (subCmds.length === 0) {
    console.log("caution:subcommand is needed");
    return;
  }
  try {
    let myProxyCmdMap = proxyCmdMap;
    for (const cmd of subCmds) {
      const _cmdMapOrFn = myProxyCmdMap[cmd];
      if (_.isFunction(_cmdMapOrFn)) {
        await _cmdMapOrFn.call(myProxyCmdMap, argv);
        return;
      }
      if (_.isObject(_cmdMapOrFn)) {
        myProxyCmdMap = _cmdMapOrFn;
        continue;
      }
      throw new Error(`no such command: ${cmd} of ${subCmds.join('=>')}`);
    }
  } catch (e) {
    console.error(e);
  }
}

exports.run = run;
