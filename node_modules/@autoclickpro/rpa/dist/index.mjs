import { screen, Region, mouse, straightTo, centerOf, keyboard, Key } from '@nut-tree/nut-js';
import fs from 'node:fs';
import dotenv from 'dotenv';
import _ from 'lodash-es';
import sharp from 'sharp';
import path from 'node:path';
import looksSame from 'looks-same';
import 'zx';

dotenv.config();
const Base_API = process.env["AUTOCLICK_BASE_URL"] || "https://api.autoclickpro.com";
const defaultQueryOption = {
  timeout: 10000,
  inPane: "wholeScreen",
  selectNth: 1,
  scrollingSearch: false,
  selectTheOneCloseTo: undefined
};
const RPA_ERROR_ID = {
  checkStability: 1
};

async function processFormApi(obj, api) {
  const formData = new FormData();
  for (const key in obj) {
    formData.append(key, obj[key]);
  }
  const res = await api(formData);
  console.log("=>fetch", res.url);
  const json = await res.json();
  const {
    data,
    code,
    message
  } = json;
  if (code !== 0) {
    console.error(json);
    throw new Error(message);
  }
  console.log("data=", data);
  return data;
}
async function findBoxByIcon(image, iconName) {
  const obj = {
    name: iconName,
    image: new File([image], "image.png", {
      type: "image/png"
    })
  };
  return processFormApi(obj, async formData => {
    return fetch(`${Base_API}/findBoxByIcon`, {
      method: "POST",
      body: formData
    });
  });
}
async function findBoxByText(image, text) {
  const obj = {
    text,
    image: new File([image], "image.png", {
      type: "image/png"
    })
  };
  return processFormApi(obj, formData => fetch(`${Base_API}/findBoxByText`, {
    method: "POST",
    body: formData
  }));
}
async function findWords(image) {
  const obj = {
    image: new File([image], "image.png", {
      type: "image/png"
    })
  };
  return processFormApi(obj, formData => fetch(`${Base_API}/ocr`, {
    method: "POST",
    body: formData
  }));
}

const floor = Math.floor.bind(Math);
async function getBoxOfScreen(pane) {
  const screenW = await screen.width();
  const screenH = await screen.height();
  const halfScreenW = floor(screenW / 2);
  const halfScreenH = floor(screenH / 2);
  const cellHeightOf9 = floor(screenH / 3);
  const cellWidthOf9 = floor(screenW / 3);
  const cellHeightOf4 = floor(screenH / 2);
  const cellWidthOf4 = floor(screenW / 2);
  switch (pane) {
    case "leftOf2":
      return {
        x: 0,
        y: 0,
        width: halfScreenW,
        height: screenH
      };
    case "rightOf2":
      return {
        x: halfScreenW,
        y: 0,
        width: halfScreenW,
        height: screenH
      };
    case "topOf2":
      return {
        x: 0,
        y: 0,
        width: screenW,
        height: halfScreenH
      };
    case "bottomOf2":
      return {
        x: 0,
        y: halfScreenH,
        width: screenW,
        height: halfScreenH
      };
    case "leftTopOf4":
      return {
        x: 0,
        y: 0,
        width: cellWidthOf4,
        height: cellHeightOf4
      };
    case "rightTopOf4":
      return {
        x: halfScreenW,
        y: 0,
        width: cellWidthOf4,
        height: cellHeightOf4
      };
    case "leftBottomOf4":
      return {
        x: 0,
        y: halfScreenH,
        width: cellWidthOf4,
        height: cellHeightOf4
      };
    case "rightBottomOf4":
      return {
        x: halfScreenW,
        y: halfScreenH,
        width: cellWidthOf4,
        height: cellHeightOf4
      };
    case "centerOf9":
      return {
        x: floor(screenW * 0.25),
        y: floor(screenH * 0.25),
        width: cellWidthOf9,
        height: cellHeightOf9
      };
    case "leftTopOf9":
      return {
        x: 0,
        y: 0,
        width: cellWidthOf9,
        height: cellHeightOf9
      };
    case "rightTopOf9":
      return {
        x: floor(screenW * 0.66),
        y: 0,
        width: cellWidthOf9,
        height: cellHeightOf9
      };
    case "topCenterOf9":
      return {
        x: floor(screenW * 0.33),
        y: 0,
        width: cellWidthOf9,
        height: cellHeightOf9
      };
    case "leftBottomOf9":
      return {
        x: 0,
        y: floor(screenH * 0.66),
        width: cellWidthOf9,
        height: cellHeightOf9
      };
    case "rightBottomOf9":
      return {
        x: floor(screenW * 0.66),
        y: floor(screenH * 0.66),
        width: cellWidthOf9,
        height: cellHeightOf9
      };
    case "bottomCenterOf9":
      return {
        x: floor(screenW * 0.33),
        y: floor(screenH * 0.66),
        width: cellWidthOf9,
        height: cellHeightOf9
      };
    case "leftCenterOf9":
      return {
        x: 0,
        y: floor(screenH * 0.33),
        width: cellWidthOf9,
        height: cellHeightOf9
      };
    case "rightCenterOf9":
      return {
        x: floor(screenW * 0.66),
        y: floor(screenH * 0.33),
        width: cellWidthOf9,
        height: cellHeightOf9
      };
    case "wholeScreen":
      return {
        x: 0,
        y: 0,
        width: screenW,
        height: screenH
      };
    default:
      throw new Error("unsupported screen location");
  }
}
function getBoxFromInPane(inPane) {
  const isBox = _.isObject(inPane) && "x" in inPane;
  switch (typeof inPane) {
    case "function":
      return inPane();
    case "string":
      return getBoxOfScreen(inPane);
    case "object":
      if (isBox) {
        return inPane;
      }
    default:
      throw new Error("no supported type");
  }
}

function box2Region(box) {
  return new Region(box.x, box.y, box.width, box.height);
}
async function moveToCenterOfBox(box) {
  await mouse.move(straightTo(centerOf(box2Region(box))));
}
function centerOfBox(box) {
  return {
    x: box.x + box.width / 2,
    y: box.y + box.height / 2
  };
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
function getBoxInScreen(grabBox, subbox) {
  return {
    x: grabBox.x + subbox.x,
    y: grabBox.y + subbox.y,
    width: subbox.width,
    height: subbox.height
  };
}
async function addRedBorder(boxes, background, output) {
  const borderThickness = 2;
  const color = {
    r: 255,
    g: 0,
    b: 0,
    alpha: 1
  };
  const base = {
    background: color,
    channels: 4
  };
  const layers = boxes.map(box => {
    return [
    // left border
    {
      input: {
        create: {
          ...base,
          width: borderThickness,
          height: box.height
        }
      },
      top: box.y,
      left: box.x
    },
    // right border
    {
      input: {
        create: {
          ...base,
          width: borderThickness,
          height: box.height
        }
      },
      top: box.y,
      left: box.width + box.x - borderThickness
    },
    // top border
    {
      input: {
        create: {
          ...base,
          width: box.width,
          height: borderThickness
        }
      },
      top: box.y,
      left: box.x
    },
    // bottom border
    {
      input: {
        create: {
          ...base,
          width: box.width,
          height: borderThickness
        }
      },
      top: box.y + box.height - borderThickness,
      left: box.x
    }];
  });
  await sharp(background).composite(layers.flat()).toFile(output);
}
async function dbgScreen(boxes, sc, output) {
  const dir = path.dirname(output);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, {
      recursive: true
    });
  }
  if (!fs.existsSync(output)) {
    fs.writeFileSync(output, "", {
      flag: "w"
    });
  }
  await addRedBorder(boxes, sc, output);
}
/**
 * if you cannot scroll down anymore, then you are at the end of the page
 * @param grabBox: the box you care about, such as the long list. if you always choose whole screen, there are some problems if the swiper existed
 * @returns
 */
async function isAtEndOfPage(grabBox) {
  const first = await screen.captureRegion("sc-1.png", box2Region(grabBox));
  await keyboard.pressKey(Key.PageDown);
  const second = await screen.captureRegion("sc-2.png", box2Region(grabBox));
  const {
    equal
  } = await looksSame(first, second);
  if (!equal) {
    await keyboard.pressKey(Key.PageUp);
    await keyboard.releaseKey(Key.PageUp);
  }
  return equal;
}

keyboard.config.autoDelayMs = 20;

/**
 * it will not scroll down automatically to find the element
 * @param q
 * @param option
 * @returns
 */
async function query(q, option = defaultQueryOption, info = "") {
  const {
    timeout = defaultQueryOption["timeout"],
    selectNth = defaultQueryOption["selectNth"],
    inPane = defaultQueryOption["inPane"],
    selectTheOneCloseTo = defaultQueryOption["selectTheOneCloseTo"],
    scrollingSearch = defaultQueryOption["scrollingSearch"]
  } = option;
  assert(!selectNth || selectNth > 0, "nth should be greater than 0");
  const grabBox = await getBoxFromInPane(inPane);
  const now = Date.now();
  while (Date.now() - now < timeout + (selectTheOneCloseTo ? 6000 : 0)) {
    try {
      // await waitUntilImageStable(grabBox, timeout);
      const sc = await screen.captureRegion("sc.png", box2Region(grabBox));
      const buffer = fs.readFileSync(sc);
      const list = await q(buffer);
      if (list.length === 0) {
        throw new Error(`not found one time`);
      }
      await dbgScreen(list.map(e => getBoxInScreen(grabBox, e)), sc, `dbg/screenshot-${info}.png`);
      let box;
      //closeToAnchor has higher priority
      if (selectTheOneCloseTo) {
        const anchorBox = await query(async sc => {
          if (selectTheOneCloseTo.type === "text") {
            return (await findBoxByText(sc, selectTheOneCloseTo.text)).list.map(e => e.box);
          } else {
            return (await findBoxByIcon(sc, selectTheOneCloseTo.icon)).list;
          }
        });
        const center = centerOfBox(anchorBox);
        const boxs = list.map(box => {
          return {
            box,
            distance: Math.sqrt((center.x - box.x) ** 2 + (center.y - box.y) ** 2)
          };
        });
        box = boxs.sort((a, b) => a.distance - b.distance)[0].box;
      } else if (selectNth > 0) {
        box = list[selectNth - 1];
        assert(!!box, `not found the ${selectNth}th box`);
      } else {
        throw new Error(`impossible, or argument error`);
      }
      console.log("find box", box);
      return getBoxInScreen(grabBox, box);
    } catch (e) {
      if (e.code === RPA_ERROR_ID.checkStability) {
        throw e;
      }
      console.log(e.message);
      const isAtEnd = await isAtEndOfPage(grabBox);
      if (scrollingSearch && !isAtEnd) {
        console.log("===>page down to find");
        await keyboard.pressKey(Key.PageDown);
        await keyboard.releaseKey(Key.PageDown);
        await mouse.scrollUp(20);
      }
    }
  }
  throw new Error(`timeout: ${info} not found `);
}

/**
 * wait for the text to appear
 * @param text
 */
function createRpa({
  dbg = true
} = {}) {
  screen.config.highlightDurationMs = 1000 * 30;
  async function findBoxByIcon$1(iconName, option = defaultQueryOption) {
    dbg && console.log("==>findIcon", iconName);
    return await query(async sc => (await findBoxByIcon(sc, iconName)).list, option, iconName);
  }
  async function findBoxByText$1(text, option = defaultQueryOption) {
    dbg && console.log("==>findText", text);
    return await query(async sc => (await findBoxByText(sc, text)).list.map(e => e.box), option, text);
  }
  return {
    async clickText(text, option = defaultQueryOption) {
      dbg && console.log("==>clickText", text);
      const box = await findBoxByText$1(text, option);
      await this.clickBox(box);
    },
    async clickIcon(iconName, option = defaultQueryOption) {
      dbg && console.log("==>clickIcon", iconName);
      const box = await findBoxByIcon$1(iconName, option);
      await this.clickBox(box);
    },
    async hasText(text, option = defaultQueryOption) {
      dbg && console.log("==>hasText", text);
      try {
        return !!(await query(async sc => (await findBoxByText(sc, text)).list.map(e => e.box), option, text));
      } catch (e) {
        console.log("===>hasTextExe", e);
        if (e.code === RPA_ERROR_ID.checkStability) {
          throw e;
        }
        return false;
      }
    },
    async clickBox(box, option = {
      pos: "center"
    }) {
      await moveToCenterOfBox(box);
      let clickPoint = null;
      switch (option.pos) {
        case "leftCenter":
          clickPoint = {
            x: box.x + 10,
            y: box.y + box.height / 2
          };
          break;
        case "center":
        default:
          clickPoint = centerOfBox(box);
      }
      mouse.move(straightTo(clickPoint));
      await mouse.leftClick();
    },
    async click(point) {
      mouse.move(straightTo(point));
      await mouse.leftClick();
    },
    async hasIcon(iconName, option = defaultQueryOption) {
      dbg && console.log("==>hasIcon", iconName);
      try {
        return !!(await query(async sc => (await findBoxByIcon(sc, iconName)).list, option, iconName));
      } catch (e) {
        console.log("===>hasIconExeception:", e);
        if (e.code === RPA_ERROR_ID.checkStability) {
          throw e;
        }
        return false;
      }
    },
    async typewrite(text) {
      await keyboard.type(text);
      console.log("input is ", text);
    },
    async clear() {
      await keyboard.pressKey(Key.LeftCmd, Key.A);
      await keyboard.releaseKey(Key.LeftCmd, Key.A);
      await keyboard.pressKey(Key.Delete);
    },
    async pressKey(...keys) {
      await keyboard.pressKey(...keys);
      await keyboard.releaseKey(...keys);
    },
    async ocr({
      inPane
    }) {
      const grabBox = await getBoxFromInPane(inPane);
      const sc = await screen.captureRegion("dbg/sc.png", box2Region(grabBox));
      const buffer = fs.readFileSync(sc);
      const {
        list
      } = await findWords(buffer);
      const listInScreen = list.map(e => ({
        ...e,
        box: getBoxInScreen(grabBox, e.box)
      }));
      await fs.writeFileSync("dbg/ocr.json", JSON.stringify(listInScreen, null, 2));
      return listInScreen;
    },
    async scroll(step) {
      switch (step) {
        case "pageDown":
          await keyboard.pressKey(Key.PageDown);
          await keyboard.releaseKey(Key.PageDown);
          break;
        case "pageUp":
          await keyboard.pressKey(Key.PageUp);
          await keyboard.releaseKey(Key.PageUp);
          break;
        case "toBottom":
          await keyboard.pressKey(Key.End);
          await keyboard.releaseKey(Key.End);
          break;
        case "toTop":
          await keyboard.pressKey(Key.Home);
          await keyboard.releaseKey(Key.Home);
          break;
        default:
          if ("x" in step && "y" in step) {
            const {
              x,
              y
            } = step;
            if (y < 0) {
              await mouse.scrollUp(-y);
            } else if (y > 0) {
              await mouse.scrollDown(y);
            }
            if (x < 0) {
              await mouse.scrollLeft(-x);
            } else if (x > 0) {
              await mouse.scrollRight(x);
            }
            return;
          }
          throw new Error("unsupported scroll");
      }
    }
  };
}
const rpa = createRpa({
  dbg: true
});

const textCmp = {
  isEqual(a, b) {
    return a.replace(/\W/g, "").toLowerCase() === b.replace(/\W/g, "").toLowerCase();
  },
  include(a, b) {
    return a.replace(/\W/g, "").toLowerCase().includes(b.replace(/\W/g, "").toLowerCase());
  }
};

export { createRpa, rpa, textCmp };
